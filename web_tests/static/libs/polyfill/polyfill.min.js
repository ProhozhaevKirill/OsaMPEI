/*
 * Polyfill Local JavaScript
 * ES6+ features for older browsers
 */
(function() {
    'use strict';

    // Object.assign polyfill
    if (typeof Object.assign !== 'function') {
        Object.assign = function(target) {
            if (target == null) {
                throw new TypeError('Cannot convert undefined or null to object');
            }

            var to = Object(target);
            for (var index = 1; index < arguments.length; index++) {
                var nextSource = arguments[index];
                if (nextSource != null) {
                    for (var nextKey in nextSource) {
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        };
    }

    // Array.from polyfill
    if (!Array.from) {
        Array.from = function(arrayLike, mapFn, thisArg) {
            var C = this;
            var items = Object(arrayLike);
            if (arrayLike == null) {
                throw new TypeError('Array.from requires an array-like object - not null or undefined');
            }
            var mapFunction = mapFn === undefined ? undefined : mapFn;
            var T;
            if (typeof mapFunction !== 'undefined') {
                if (typeof mapFunction !== 'function') {
                    throw new TypeError('Array.from: when provided, the second argument must be a function');
                }
                if (arguments.length > 2) {
                    T = thisArg;
                }
            }
            var len = parseInt(items.length);
            var A = typeof C === 'function' ? Object(new C(len)) : new Array(len);
            var k = 0;
            var kValue;
            while (k < len) {
                kValue = items[k];
                if (mapFunction) {
                    A[k] = typeof T === 'undefined' ? mapFunction(kValue, k) : mapFunction.call(T, kValue, k);
                } else {
                    A[k] = kValue;
                }
                k += 1;
            }
            A.length = len;
            return A;
        };
    }

    // Promise polyfill (basic)
    if (typeof Promise === 'undefined') {
        window.Promise = function(executor) {
            var self = this;
            self.state = 'pending';
            self.value = undefined;
            self.handlers = [];

            function resolve(result) {
                if (self.state === 'pending') {
                    self.state = 'fulfilled';
                    self.value = result;
                    self.handlers.forEach(function(handler) {
                        handler.onFulfilled(result);
                    });
                }
            }

            function reject(error) {
                if (self.state === 'pending') {
                    self.state = 'rejected';
                    self.value = error;
                    self.handlers.forEach(function(handler) {
                        handler.onRejected(error);
                    });
                }
            }

            self.then = function(onFulfilled, onRejected) {
                return new Promise(function(resolve, reject) {
                    function handle() {
                        if (self.state === 'fulfilled' && onFulfilled) {
                            try {
                                resolve(onFulfilled(self.value));
                            } catch (ex) {
                                reject(ex);
                            }
                        } else if (self.state === 'rejected' && onRejected) {
                            try {
                                resolve(onRejected(self.value));
                            } catch (ex) {
                                reject(ex);
                            }
                        } else if (self.state === 'fulfilled') {
                            resolve(self.value);
                        } else if (self.state === 'rejected') {
                            reject(self.value);
                        } else {
                            self.handlers.push({
                                onFulfilled: function(result) {
                                    if (onFulfilled) {
                                        try {
                                            resolve(onFulfilled(result));
                                        } catch (ex) {
                                            reject(ex);
                                        }
                                    } else {
                                        resolve(result);
                                    }
                                },
                                onRejected: function(error) {
                                    if (onRejected) {
                                        try {
                                            resolve(onRejected(error));
                                        } catch (ex) {
                                            reject(ex);
                                        }
                                    } else {
                                        reject(error);
                                    }
                                }
                            });
                        }
                    }
                    handle();
                });
            };

            try {
                executor(resolve, reject);
            } catch (ex) {
                reject(ex);
            }
        };
    }

    console.log('Polyfills loaded successfully');
})();